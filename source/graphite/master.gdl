////////////////////////////////////////////////////////////////////////////////////////////
//
//	File: Scheherazade.gdl
//
//	Main Graphite code file for Scheherazade, including all rules.
//
////////////////////////////////////////////////////////////////////////////////////////////

/*
	This file is part of Scheherazade font family 
	(http://scripts.sil.org/Scheherazade) and is 
	Copyright (c) 1994-2014 SIL International (http://www.sil.org/),
	with Reserved Font Names "Scheherazade" and "SIL".

	This Font Software is licensed under the SIL Open Font License,
	Version 1.1.

	You should have received a copy of the license along with this Font Software.
	If this is not the case, go to (http://scripts.sil.org/OFL) for all the
	details including an FAQ.
*/


#include "stddef.gdh"
AutoPseudo = 0;
ScriptDirection = HORIZONTAL_RIGHT_TO_LEFT;
Bidi = true;

environment {MUnits=2048};

// Temporary until incorporated into stddef.h:
#define DIR_NSM 16		// not defined in stddef.h but is in the compiler
#define DIR_LRI 17		// These 4 new to Unicode 6.3
#define DIR_RLI 18
#define DIR_FSI 19
#define DIR_PDI 20

#if 0   // DESIGN NOTES

One of the complex issues is mark attachment. Problems stem from the following issues:

1) Do we require marks to be in a particular order?
	The typical sequence of marks is shadda or hamza, followed by vowel, followed by quranic mark.
	Windows Arabic uses this order, but a canonical Unicode string will not always be in this order.
	Further, non-canonical Unicode strings can have the marks in any order.
	Decision: We need to support any order.

2) Do we visually identify illogical mark sequences?
	While the order of the marks on a given base is variable, certain marks should not occur
	simultaneously. For example, no more than one vowel mark should occur. If two vowels occur on 
	the same base, we can visually identify this error by inserting a dotted circle between them
	which will then act as a base for the second vowel.
	But detecting this if we allow any order vowels (see 1) is a bit tricky. 
	Decision: We want to provide this valuable feedback. 

3) Exactly what marks are mutually exclusive? Seems clear that the vowels (e.g kasra, fatha, damma,
	kasratan, fathatan, dammatan, sukun) are mutually exclusive with each other. For Arabic
	shadda, hamza above, hamza below, and maddah are also mutually exclusive, but I don't know about
	other languages. I also don't know about the remaining (i.e., quranic) marks.
	Decision: assume shadda, hamza a/b, maddah and mark noon ghunna are mutually exclusive, and vowel
	marks are mutually exclusive.
	
4) However, maddah works differently from shadda and hamza
	in that it is placed above the vowel rather than below. (For example, superscript alef + maddah)

To accomplish all this, the design we use is to reorder the marks to a logical
order based on 4 classes:
	cMark1 class contains shadda, hamza, mark noon ghunna
	cMark2 class contains the vowels
	cMark3 class contains maddah
	cMark4 class contains quranic marks and Rohingya tones
	
Only cMark2 and cMark4 can have duplicates. Except right now there are no outer attachment points for the
quranic marks, so multiples don't work right.


#endif

// Glyph definitions and rules for codepage 1252 composites
#include "cp1252.gdl"

// Hard-coded glyph and class definitions:
#include "SchGlyphs.gdh"

// Features 
#include "SchFeatures.gdh"


#define alefAttached user1

#ifndef opt2
#define opt(x)      [x]?
#define opt2(x)     [opt(x) x]?
#define opt3(x)     [opt2(x) x]?
#define opt4(x)     [opt3(x) x]?
#endif


// Now add additional classes we need:

table(glyph)

	cShaddaKasraLigatures {
		component.shadda = box(bb.left, bb.bottom, bb.right, bb.bottom + bb.height/2);
		component.kasra  = box(bb.left, bb.bottom + bb.height/2, bb.right, bb.top)
	};

endtable; // glyph

// Allow a sequence of up to 4 marks.
#define MARKS [ cAnyMarks [ cAnyMarks [ cAnyMarks cAnyMarks? ]? ]? ]?

#define MARKSBELOW [ cAnyMarksBelow [ cAnyMarksBelow cAnyMarksBelow? ]? ]?

#define MARKSABOVE [ cAnyMarksAbove [ cAnyMarksAbove cAnyMarksAbove? ]? ]?


//-- Substitution ---

table(substitution)

pass(1) {Direction = LEFT_TO_RIGHT}	// Encoding, decomposition, mirroring

	
	// NB: This pass also includes cp1252 compositions
	
	// NB: I think that even though this is an ABS decomposition, it can be done in a LTR pass because
	//     the reverser will make sure the mark always follows the base:
	// QUESTION: are there more things that need to be decomposed?
	cAlefPlusMark _ >  g_alef_ar:1  cAlefMark$1:1 ;
	
//	if (graphite1mirror)    // No longer support Graphite 1 mirroring?
//		(cMirrorOpen cMirrorClose)  >  (cMirrorClose cMirrorOpen);
//	endif;
	
	// The following is a debugging tool so you can find out whether the app is rendering with Graphite or not.
	// The string "RenderingUnknown" will be rendered as "RenderingGraphite":
	
	codepoint("U") codepoint("n") codepoint("k") codepoint("n") codepoint("o") codepoint("w") codepoint("n") _               > 
	codepoint("G") codepoint("r") codepoint("a") codepoint("p") codepoint("h") codepoint("i") codepoint("t") codepoint("e"):16  / 
		codepoint("R") codepoint("e") codepoint("n") codepoint("d") codepoint("e") codepoint("r") codepoint("i") codepoint("n") codepoint("g")  _ _ _ _ _ _ _ _;

	// Subtending marks
	// This is in a LTR pass because they are category (AN) and the digits that follow are collected into
	// a LTR sequence by the bidi algorithm.
	
	cSignTakes4 cDigitsAny cDigitsAny cDigitsAny cDigitsAny  >
		cSign4 cDigitsAnyMedium cDigitsAnyMedium cDigitsAnyMedium cDigitsAnyMedium;

	cSignTakes3Medium cDigitsAny cDigitsAny cDigitsAny  >
		cSign3Medium cDigitsAnyMedium cDigitsAnyMedium cDigitsAnyMedium;
		
	cSignTakes3Small cDigitsAny cDigitsAny cDigitsAny  >
		cSign3Small cDigitsAnySmall cDigitsAnySmall cDigitsAnySmall;
		
	cSignTakes2 cDigitsAny cDigitsAny  >
		cSign2 cDigitsAnyMedium cDigitsAnyMedium;

	cSignTakes1 cDigitsAny  >  cSign1  cDigitsAnyMedium;
	
endpass; // 1


pass(2) {MaxRuleLoop = 10}

	// Simulation of UTR53 - mark reordering
	
	// Notes:
	// 1) We don't swap the glyphs, because that would mess up the original order,
	//    rather we delete and insert.
	// 2) glyphs for fixed-position combining classes (other than shadda and daggeralef)
	//    won't be ordered correctly relative to each other, but usually not more than one anyway.

	_  cUTR53_1_skip=S  cUTR53_1=M  > @M:M  @S  _ /  ^  _  _  opt4(cUTR53_1_skip)  _; // move 220 MCM to front
	_  cUTR53_2_skip=S  cUTR53_2=M  > @M:M  @S  _ /  ^  _  _  opt4(cUTR53_2_skip)  _; // move 230 MCM to just after 220 MCM
	_  cUTR53_3_skip=S  cUTR53_3=M  > @M:M  @S  _ /  ^  _  _  opt4(cUTR53_3_ctx)   _; // shadda is next
	_  cUTR53_4_skip=S  cUTR53_4=M  > @M:M  @S  _ /  ^  _  _  opt4(cUTR53_4_ctx)   _; // other fixed position glyphs (except daggeralef)
	_  cUTR53_5_skip=S  cUTR53_5=M  > @M:M  @S  _ /  ^  _  _  opt4(cUTR53_5_ctx)   _; // daggeralef
	_  cUTR53_6_skip=S  cUTR53_6=M  > @M:M  @S  _ /  ^  _  _  opt4(cUTR53_6_skip)  _; // other 220 in front of remaining 230.

endpass; // 2


pass(3)	// ligature diacritics

if (shaddaKasra == std || shaddaKasra == raised)
		g_shadda_ar  cShaddaKasraMarks  >  _  cShaddaKasraLigatures:(S K)  /  _=S  g_graphemejoinercomb?  _=K;
		cShaddaKasraMarks  g_shadda_ar  >  cShaddaKasraLigatures:(K S)  _  /  _=K  g_graphemejoinercomb?  _=S;
endif;

	
	// QUESTION: do we really need these if we're doing the reordering above?
	// TODO: if we use them, make them into real ligatures
	//absShadda     cShaddaMarks >  _  cShaddaLigatures:(1 2);
	//absHamzaAbove cHamzaMarks  >   _ cHamzaLigatures:(1 2);

endpass; // 3


pass(4)	// Contextual forms, lam-alef ligature, subtending marks

	// Lam-alef
	
	// Here is JK's elegant solution to contextual forms using a ligature glyph...
/***
	(absLam absLamFin)=L  absAlef=A  > 
		(absLamAlef absLamAlefFin):(L A) {component {lam.ref = @L; alef.ref=@A } } gAlefPlaceholder
		/ _  MARKS  _  MARKS ^;
***/
	// ...but we're using two separate glyphs, because of all the combinations.
	cLamIso cAlefIso  >  cLamIniBeforeAlef {alefAttached = false}  cAlefFinAfterLamIni  / _ MARKS ^ _ ;
	cLamFin cAlefIso  >  cLamMedBeforeAlef {alefAttached = false}  cAlefFinAfterLamMed  / _ MARKS ^ _ ;

	// All other contextual forms
	
	(cDualLinkIsol cDualLinkFina g_kashida_ar zeroWidthJoiner) (cDualLinkIsol cRightLinkIsol g_kashida_ar zeroWidthJoiner) > 
		(cDualLinkInit cDualLinkMedi g_kashida_ar zeroWidthJoiner) (cDualLinkFina cRightLinkFina g_kashida_ar zeroWidthJoiner)
		/ _  MARKS ^ _ ;

endpass; // 4


pass(5)	// Features, special behaviors

	cLowHamzaBase  g_hamzaabove_ar  >  cLowHamzaComposed:(1 2)  _;
	
	// Allah ligatures:
	// Also see pass 6 below.

	// Rule 3:
	
	// alefIso-lam-lam-heh
	g_alef_ar  g_lam_ar_init  g_lam_ar_medi  _  _  (g_heh_ar_fina g_hehgoal_ar_fina) 
		> g_alef_ar_allah  g_lam_ar_allah1_init  g_lam_ar_allah2_medi=L  g_shadda_ar:L  g_alefabove_ar:L  (g_heh_ar_allah_fina g_hehgoal_ar_allah_fina) 
		/ _ MARKS _ _ _ _ _;

	// Rule 2:

	// lamInit-lam-shadda-alef-heh
	g_lam_ar_init  g_lam_ar_medi  (g_heh_ar_fina g_hehgoal_ar_fina) 
		> g_lam_ar_allah1_init  g_lam_ar_allah2_medi  (g_heh_ar_allah_fina g_hehgoal_ar_allah_fina)
		/ (cRightLinkIsol cRightLinkFina) MARKS _ _ g_shadda_ar (g_alefabove_ar g_fatha_ar) _;

	// lamInit-lam-alef-shadda-heh
	g_lam_ar_init  g_lam_ar_medi  (g_heh_ar_fina g_hehgoal_ar_fina) 
		> g_lam_ar_allah1_init  g_lam_ar_allah2_medi  (g_heh_ar_allah_fina g_hehgoal_ar_allah_fina)
		/ (cRightLinkIsol cRightLinkFina) MARKS _ _ (g_alefabove_ar g_fatha_ar) g_shadda_ar _;

	// lamMedi-lam-shadda-alef-heh
	g_lam_ar_medi g_lam_ar_medi  (g_heh_ar_fina g_hehgoal_ar_fina) 
		> g_lam_ar_allah1_medi  g_lam_ar_allah2_medi  (g_heh_ar_allah_fina g_hehgoal_ar_allah_fina)
		/ (cDualLinkInit cDualLinkMedi) MARKS _ _ g_shadda_ar (g_alefabove_ar g_fatha_ar) _;

	// lamMedi-lam-alef-shadda-heh
	g_lam_ar_medi g_lam_ar_medi  (g_heh_ar_fina g_hehgoal_ar_fina) 
		> g_lam_ar_allah1_medi  g_lam_ar_allah2_medi  (g_heh_ar_allah_fina g_hehgoal_ar_allah_fina)
		/ (cDualLinkInit cDualLinkMedi) MARKS _ _ (g_alefabove_ar g_fatha_ar) g_shadda_ar _;
	
	// Features

	if (dalAlt == senegal)
		cDalIso  >  cDalIso_sen;
	endif;
	
	if (meemAlt == sindhi)
		cMeem  >  cMeem_sindhi;
	endif;
	
	if (hehAlt == kurdish)
		cno_Heh  >  cHehKurdish;
	endif;
	if (hehAlt == sindhi)
		cno_Heh  >  cHehSindhi;
	endif;
	if (hehAlt == urdu)
		cno_Heh  >  cHehUrdu;
	endif;

// obsolete
//	if (UAlt == filled)
//		cU  >  cU_filled;
//	endif;

	if (kirghizOeAlt == bar)
		(g_kirghizoe_ar  g_kirghizoe_ar_fina)  >  (g_kirghizoe_ar_bar  g_kirghizoe_ar_bar_fina);
	endif;

	if (yehHamzaAlt == kirghiz)
		(g_yeh_hamzaabove_ar  g_yeh_hamzaabove_ar_fina)  >  (g_yeh_hamzaabove_ar_locl_k_i_r  g_yeh_hamzaabove_ar_locl_k_i_r_fina);
	endif;

	if (maddahAlt != large)
		cMaddah > cMaddah_small;
	endif;
	
	if (dammaAlt == filled)
		cDamma > cDamma_filled;
	endif;
	if (dammaAlt == short)
		cDamma > cDamma_short;
	endif;

	if (dammatanAlt == sixNine)
		cDammatan > cDammatan_sixNine;
	endif;

	if (daggeralefAlt == large)
		g_alefabove_ar  >  g_alefabove_ar_large  /  cTakesLargeDaggerAlef  _;
	endif;
	// daggeralefAlt == 2 -> remains small

	if (ultapeshAlt == hollow)
		g_dammainverted_ar > g_dammainverted_ar_open;
	endif;
	if (ultapeshAlt == filled)
	  g_dammainverted_ar_open > g_dammainverted_ar;  // needed for Wolof, with default = hollow
	endif;

	if (sukunAlt == jasmDown)
		cno_Sukun  >  cSukunDownOpen;
	endif;
	if (sukunAlt == jasmLeft)
		cno_Sukun  >  cSukunLeftOpen;
	endif;
	
	if (endOfAyah == circle)
		cEndOfAyah  >  cEndOfAyahCircle;
	endif;
	if (endOfAyah == square)
		cEndOfAyah  >  cEndOfAyahSquare;
	endif;
	
		
	if (easternDigits == sindhi)
		cEasternDigit  >  cEasternDigitSindhi;
	endif;
	if (easternDigits == urdu)
		cEasternDigit  >  cEasternDigitUrdu;
	endif;
	if (easternDigits == rohingya)
		cEasternDigit  >  cEasternDigitRohingya;
	endif;
	
	if (commaAlt == down)
		cno_Downward  >  cDownward;
	endif;
	
/*--- OBSOLETE FEATURES ---
	if (jehHack == dotHat)
		cJeh > cJeh_dotHat;
	endif;
	
	if (headOfKhahHack == openLeft)
		cno_OpenLeft > cOpenLeft;	endif;
-------------------------*/
	
	//if (!invis) // always true now that we have disabled the feature
	
		// Note that substitution changes the directionality to the defaults for the
		// substituted glyph. :-( So be sure to fix it:
		cInvisible > zeroWidthSpace {directionality = @1.directionality};
		
	//endif; 
	
endpass; // 5


pass(6)
	// Allah clean-up.
	(g_alef_ar  g_alef_ar_fina)                >  (g_alef_ar_allah g_alef_ar_allah_fina)          /  _  MARKS  g_lam_ar_allah1_init;
	(g_alef_wasla_ar g_alef_wasla_ar_fina)  _  >  (g_alef_ar_allah g_alef_ar_allah_fina):1  g__wasla:1 /  _  _ MARKS  g_lam_ar_allah1_init;

	g_shadda_ar  g_alefabove_ar  >  g_shadda_alef_ar:(2 3)  _ /  g_lam_ar_allah2_medi  _  _;

	// Other:
	g_hamzaabove_ar  (g_damma_ar  g_damma_ar_filled  g_damma_ar_short)  
		>  _  (g_hamza_damma_ar  g_hamza_damma_ar_filled  g_hamza_damma_ar_short):(1 2);
endpass;

endtable; // sub


//table(glyph)
//cMark1Below_volt += (g_graphemejoinercomb);
//cMark2Below_volt += (g_graphemejoinercomb);
//cAnyMarksBelow += (g_graphemejoinercomb);
//endtable;

//-- Positioning ---

table (positioning)

// Must allow for at least cMark1Below and/or cMark2Below to intervene between base and marks above.
// The code below is more general.

pass(1)

	// Lam-alef components:
	cHasExit=L {alefAttached = true}  cHasEntry=A {attach {to=@L; at=exitS; with=entryS}; insert=true}
		/ ^ _ {alefAttached == false}  MARKS  _;
	
	// Mark attachment

	// Note: the superscript-alef may have both the _alef and _diaA att pts; the ordering of these
	// rules assumes the alef AP should be used if there are no intervening marks.
	cHasAlefAP=B  cMarkSuperscriptAlefs {attach {to=@B; at=alefS; with=alefM}; insert = true}  / _ ^ MARKSBELOW _ ;
	
/****
	// Special case: cozy up these diacritics a little, so they look more like the built-in ligatures:
	g_shadda_ar=S
		(g_fatha_ar  g_damma_ar  g_fathatan_ar  g_dammatan_ar)
			{attach {to=@S; at=point(diaAS.x,diaAS.y-80m); with=diaAM} }
		/ _ ^ opt4(cndiaADia)  _;

	g_hamzaabove_ar=H
		(g_fatha_ar  g_damma_ar  g_fathatan_ar  g_dammatan_ar)
			{attach {to=@H; at=point(diaAS.x+40m,diaAS.y-80m); with=diaAM} }
		/ _ ^ opt4(cndiaADia)  _;
****/

	calefDia {attach {to = @1; at = alefS; with = alefM}} / cTakesalefDia opt4(cndiaADia) _;
	cdiaADia {attach {to = @1; at = diaAS; with = diaAM}} / cTakesdiaADia opt4(cndiaADia) _;
	cdiaBDia {attach {to = @1; at = diaBS; with = diaBM}} / cTakesdiaBDia opt4(cndiaBDia) _;


	// Normal case - OLD
//	(cBaseAny cMark1Above_volt cMarkSuperscriptAlefs)=B  (cAnyMarksAbove) {attach {to=@B; at=diaAS; with=diaAM} }
//		/ _ ^ MARKSBELOW  _;


	// Subtending marks
	// NB: at this point digits should be in visual order, right to left,
	// so we attach the left-most (logically first) to the sign, and proceed to the right.
	
	
	cSignDigit=D4 { attach {to=@D3; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitRS; with=digitLS }; insert = true}
	cSign4=S;

	cSignDigit=D3 { attach {to=@D2; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitRS; with=digitLS }; insert = true}
	cSign3=S;

	cSignDigit=D2 { attach {to=@D1; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D1 { attach {to=@S;  at=digitRS; with=digitLS }; insert = true}
	cSign2=S;

	cSignDigit { attach {to=@S;  at=digitRS; with=digitLS }; insert = true}
	cSign1=S;
	
	// However, there is a bug in some integrations (e.g., Firefox) 
	// such that the glyps are still in logical order:
	
	cSign4=S
	cSignDigit=D1 { attach {to=@S;  at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D4 { attach {to=@D3; at=digitRS; with=digitLS }; insert = true};
	
	cSign3=S
	cSignDigit=D1 { attach {to=@S;  at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D3 { attach {to=@D2; at=digitRS; with=digitLS }; insert = true};
	

	cSign2=S
	cSignDigit=D1 { attach {to=@S;  at=digitRS; with=digitLS }; insert = true}
	cSignDigit=D2 { attach {to=@D1; at=digitRS; with=digitLS }; insert = true};
	

	cSign1=S
	cSignDigit { attach {to=@S;  at=digitRS; with=digitLS }; insert = true};
	
	

endpass; // 1

pass(2)

	// Marks below

	// Special attachment points for lam-alef ligatures, to avoid collisions:
	cAllAlefFinAfterLam=B cAnyMarksBelow {attach {to=@B; at=dia2BS; with=dia2BM} }
		/ (g_lam_threedotsabove_ar_pre_alef_init g_lam_threedotsabove_ar_pre_alef_medi cAnyMarksBelow) MARKSABOVE _ ^ MARKSABOVE _ ;

	// Normal case - OLD
//	(cBaseAny cMark1Below_volt)=B  cAnyMarksBelow {attach {to=@B; at=diaBS; with=diaBM} }
//		/ _ ^ MARKSABOVE  _;

endpass; // 2

if (debug == false)

pass(3)
	// Kerning of reh-like and waw-like
	
	// tighten to following gaf-like 
	cRehKernGaf {advance.x -= 650m} / (cRehWawTighten cRehWawTightenMore) MARKSBELOW _ ;
	
	// loosen from following alef/lam when it has something below it
	g_alef_wavyhamzabelow_ar  {advance.x += 290m}  /  g_reh_ar  MARKS _ MARKS ANY?; // this combination needs a little more
	cAlefLamWBelow {advance.x += 215m} / cRehWawAll MARKS _ ;
	cAlefIso {advance.x += 215m} / cRehWawAll MARKS _ MARKS cAnyMarksBelow ;
	
	// loosen from following narrow initials with something below
	cNarrowIni {advance.x += 130m} / cRehWawAll MARKS _ MARKS cAnyMarksBelow ;
	
	// leave certain cases alone:
	(cRehKernAlef cRehKernOther) / (cRehWawTighten cRehWawTightenMore) MARKS                   _ MARKS cAnyMarksBelow ;
	cRehKernOtherMA              / (cRehWawTighten cRehWawTightenMore) MARKS cMarksAbove MARKS _ MARKS cAnyMarksAbove ;
	 
	// otherwise tighten against most things
	cRehKernAlef {advance.x -= 190m} / (cRehWawTighten cRehWawTightenMore) MARKSBELOW _ ;
	(cRehKernOther cRehKernOtherMB) {advance.x -= 190m} / (cRehWawTighten cRehWawTightenMore) MARKS _ ;  // previous version required only one "direction" of marks, no idea why

	// tighter against Ain-like initials unless it has marks Below
	cAinLikeInit                     / (cRehWawTighten cRehWawTightenMore) MARKS _ MARKS cMarksBelow ;
	cAinLikeInit {advance.x -= 215m} / cRehWawTighten     MARKS _ ;
	cAinLikeInit {advance.x -= 290m} / cRehWawTightenMore MARKS _ ;
	
	// tighter still for some reh/wah followed by Ain-like isolates
	cAinLikeIsol {advance.x -= 580m} / cRehWawNothingBelow MARKSABOVE _ ;
	
endpass; // 3

endif;


///////////////////////////////////////////////////////////////////

//////#if 0   // SC's actual collision handling disabled for now
	
// Everything else is SC's collision handling 

table(glyph)	// classes for collision handling
// (now in VOLT) cNoonGhunna = (absNoonGhunna absNoonGhunnaIni absNoonGhunnaMed absNoonGhunnaFin);

cRnoonLikeMed = (g_rnoon_ar_medi  g_highhamza_yeh_ar_medi);	// Expanded to 5.1  // TODO: extend this group?
cKafLikeIniMed = // Kaf-like in initial or medial  // TODO: SC included absQafThreeDotsAbove ?
		(g_keheh_ar_init  g_gaf_ar_init  g_gaf_ring_ar_init  g_gaf_threedots_ar_init  g_gaf_twodotsbelow_ar_init  
		g_gueh_ar_init  g_kaf_dotabove_ar_init  g_kaf_ar_init  g_kaf_ring_ar_init
		g_keheh_threedotsbelow_ar_init  g_kaf_twodotshorizontalabove_ar_init  g_keheh_dotabove_ar_init
		g_keheh_threedotsabove_ar_init  g_keheh_threedotsbelow_ar_init  
		g_keheh_threedotsupbelow_ar_init  g_keheh_twodotshorizontalabove_ar_init  
		g_ng_ar_init  g_ngoeh_ar_init  g_gaf_invertedstroke_ar_init

		g_keheh_ar_medi  g_gaf_ar_medi  g_gaf_ring_ar_medi  g_gaf_threedots_ar_medi  g_gaf_twodotsbelow_ar_medi
		g_gueh_ar_medi  g_kaf_dotabove_ar_medi  g_kaf_ar_medi  g_kaf_ring_ar_medi
		g_keheh_threedotsbelow_ar_medi  g_kaf_twodotshorizontalabove_ar_medi  g_keheh_dotabove_ar_medi
		g_keheh_threedotsabove_ar_medi  g_keheh_threedotsbelow_ar_medi  
		g_keheh_threedotsupbelow_ar_medi  g_keheh_twodotshorizontalabove_ar_medi  
		g_ng_ar_medi  g_ngoeh_ar_medi  g_gaf_invertedstroke_ar_medi );

cKehehLikeFin = (
		g_keheh_twodotshorizontalabove_ar_fina  g_keheh_threedotsbelow_ar_fina
		g_keheh_ar_fina  g_keheh_dotabove_ar_fina  g_keheh_threedotsabove_ar_fina
		g_keheh_threedotsupbelow_ar_fina  g_kaf_ring_ar_fina  
		g_gaf_ar_fina  g_gaf_ring_ar_fina  g_gaf_threedots_ar_fina  g_gaf_twodotsbelow_ar_fina
		g_gaf_invertedstroke_ar_fina  g_ngoeh_ar_fina  g_gueh_ar_fina );
		

cTooth0Below = // nothing below		// TODO: SC included absTehRingIni/Med -- what about absNoonRingIni/Med?
								// I think these two should be in cTooth1hBelow, so I've put them there.
		(g_teh_ar_init  g_theh_ar_init  g_tteh_ar_init  g_tteheh_ar_init  // g_teh_ring_ar_init ???
		g_beheh_ar_init  g_beh_vabove_ar_init  g_teh_threedotsdown_ar_init  g_teheh_ar_init
		g_yeh_hamzaabove_ar_init  g_alef_maksura_ar_init  g_yeh_ar_no_dots_init  g_highhamza_yeh_ar_init
		g_noon_ar_init  g_noon_tahabove_ar_init   g_noonghunna_ar_init  g_rnoon_ar_init  g_noon_vabove_ar_init
		g_noon_african_ar_init  g_noon_threedotsabove_ar_init

		g_teh_ar_medi  g_theh_ar_medi  g_tteh_ar_medi  g_tteheh_ar_medi  // g_teh_ring_ar_medi ???
		g_beheh_ar_medi  g_beh_vabove_ar_medi  g_teh_threedotsdown_ar_medi  g_teheh_ar_medi
		g_yeh_hamzaabove_ar_medi  g_alef_maksura_ar_medi  g_yeh_ar_no_dots_medi  g_highhamza_yeh_ar_medi
		g_noon_ar_medi  g_noon_tahabove_ar_medi   g_noonghunna_ar_medi  g_rnoon_ar_medi  g_noon_vabove_ar_medi
		g_noon_african_ar_medi  g_noon_threedotsabove_ar_medi );

// In the following two groups define "tooth" shapes with dots or something else below,
// the number of dots below is based on vertical height requirements:

cTooth1hBelow = // one dot high below
		(g_beh_ar_init  g_beh_threedotsupbelow_ar_init  g_beh_threedotshorizontalbelow_ar_init
		g_beh_twodotsbelow_dotabove_ar_init  g_behhamzaabove_ar_init
		g_yeh_vinverted_farsi_init  g_yeh_twodotsabove_farsi_init
		g_yeh_threedotsabove_farsi_init  g_yeh_ar_init  g_yeh_farsi_init  g_yeh_vabove_ar_init
		g_yeh_twoabove_farsi_init  g_yeh_threeabove_farsi_init
		g_yeh_twodotsbelow_hamzaabove_ar_init  g_yeh_twodotsbelow_dotabove_ar_init
		g_yehbarree_twoabove_ar_init  g_yehbarree_threeabove_ar_init
		g_noon_dotbelow_ar_init  g_noon_twodotsbelow_ar_init  g_noon_ring_ar_init  g_teh_ring_ar_init

		g_beh_ar_medi  g_beh_threedotsupbelow_ar_medi  g_beh_threedotshorizontalbelow_ar_medi
		g_beh_twodotsbelow_dotabove_ar_medi  g_behhamzaabove_ar_medi
		g_yeh_vinverted_farsi_medi  g_yeh_twodotsabove_farsi_medi
		g_yeh_threedotsabove_farsi_medi  g_yeh_ar_medi  g_yeh_farsi_medi  g_yeh_vabove_ar_medi
		g_yeh_twoabove_farsi_medi  g_yeh_threeabove_farsi_medi
		g_yeh_twodotsbelow_hamzaabove_ar_medi  g_yeh_twodotsbelow_dotabove_ar_medi
		g_yehbarree_twoabove_ar_medi  g_yehbarree_threeabove_ar_medi
		g_noon_dotbelow_ar_medi  g_noon_twodotsbelow_ar_medi  g_noon_ring_ar_medi  g_teh_ring_ar_medi
); 
		

cTooth2hBelow = // multiple dot high below
		(g_peh_ar_init  g_beheh_ar_init  g_beeh_ar_init
		g_teh_threedotsupbelow_ar_init  g_beh_threedotsupbelow_ar_init
		g_beh_vinvertedbelow_ar_init  g_beh_vbelow_ar_init  g_yeh_kashmiri_ar_init
		g_e_ar_init  g_yeh_threedotsbelow_ar_init  g_yeh_fourbelow_farsi_init
		g_noon_threedotsabove_ar_init

		g_peh_ar_medi  g_beheh_ar_medi  g_beeh_ar_medi
		g_teh_threedotsupbelow_ar_medi  g_beh_threedotsupbelow_ar_medi
		g_beh_vinvertedbelow_ar_medi  g_beh_vbelow_ar_medi  g_yeh_kashmiri_ar_medi
		g_e_ar_medi  g_yeh_threedotsbelow_ar_medi  g_yeh_fourbelow_farsi_medi
		g_noon_threedotsabove_ar_medi	); 

// In the following two groups define "tooth" shapes with dots or something else below,
// the number of dots below is based on horizontal width requirements:

cTooth1wBelow = // one dot wide below 		// Expanded to 5.1
		(g_beh_ar_init  g_beeh_ar_init  g_beh_threedotsupabove_ar_init  g_behhamzaabove_ar_init
		g_noon_dotbelow_ar_init  g_e_ar_init
		g_beh_ar_medi  g_beeh_ar_medi  g_beh_threedotsupabove_ar_medi  g_behhamzaabove_ar_medi
		g_noon_dotbelow_ar_medi  g_e_ar_medi );

cTooth2wBelowIni = // multiple dots wide below, initial
		(g_yehbarree_twoabove_ar_init  g_yehbarree_twoabove_ar_init
		g_teh_ring_ar_init  g_peh_ar_init  g_beheh_ar_init  g_beh_threedotshorizontalbelow_ar_init
		g_beh_threedotsupbelow_ar_init  g_teh_threedotsupbelow_ar_init
		g_beh_twodotsbelow_dotabove_ar_init  g_beh_vinvertedbelow_ar_init
		g_beh_vbelow_ar_init  g_yeh_kashmiri_ar_init  g_yeh_vinverted_farsi_init
		g_yeh_twodotsabove_farsi_init  g_yeh_threedotsabove_farsi_init  g_yeh_farsi_init
		g_yeh_vabove_ar_init  g_yeh_threedotsbelow_ar_init  g_yeh_twoabove_farsi_init
		g_yeh_threeabove_farsi_init   g_yeh_fourbelow_farsi_init
		g_yeh_twodotsbelow_hamzaabove_ar_init  g_yeh_twodotsbelow_dotabove_ar_init
		g_noon_threedotsabove_ar_init  g_noon_twodotsbelow_ar_init );
		
cTooth2wBelowMed = // multiple dots wide below, medial
		(g_yehbarree_twoabove_ar_medi  g_yehbarree_threeabove_ar_medi
		g_teh_ring_ar_medi  g_peh_ar_medi  g_beheh_ar_medi  g_beh_threedotshorizontalbelow_ar_medi
		g_beh_threedotsupbelow_ar_medi  g_teh_threedotsupbelow_ar_medi
		g_beh_twodotsbelow_dotabove_ar_medi  g_beh_vinvertedbelow_ar_medi
		g_beh_vbelow_ar_medi  g_yeh_kashmiri_ar_medi  g_yeh_vinverted_farsi_medi
		g_yeh_twodotsabove_farsi_medi  g_yeh_threedotsabove_farsi_medi  g_yeh_farsi_medi
		g_yeh_vabove_ar_medi  g_yeh_threedotsbelow_ar_medi  g_yeh_twoabove_farsi_medi
		g_yeh_threeabove_farsi_medi   g_yeh_fourbelow_farsi_medi
		g_yeh_twodotsbelow_hamzaabove_ar_medi  g_yeh_twodotsbelow_dotabove_ar_medi
		g_noon_threedotsabove_ar_medi  g_noon_twodotsbelow_ar_medi );


cYehLikeFin = (					// TODO: Should this include absKashmiriYehFin ?
		g_yeh_vinverted_farsi_fina  g_yeh_twodotsabove_farsi_fina  g_yeh_threedotsabove_farsi_fina
		g_teh_ar_fina  g_yeh_farsi_fina  g_yeh_vabove_ar_fina
		g_yeh_twoabove_farsi_fina  g_yeh_threeabove_farsi_fina
		g_yeh_hamzaabove_ar_fina  g_alef_maksura_ar_fina  g_yeh_ar_no_dots  g_highhamza_yeh_ar_fina
		g_e_ar_fina  g_yeh_threedotsbelow_ar_fina  g_yeh_fourbelow_farsi_fina
		g_yeh_twodotsbelow_hamzaabove_ar_fina  g_yeh_twodotsbelow_dotabove_ar_fina  g_yeh_tail_ar_fina );
		
cTchehLikeFin = (				// Expanded to 6.1 
								// Now including AIN and YehBarree (and friends)

		g_tcheh_ar_fina  g_hah_ar_fina  g_jeem_ar_fina  g_khah_ar_fina  g_hah_hamzaabove_ar_fina
		g_hah_twodotsverticalabove_ar_fina  g_nyeh_ar_fina  g_dyeh_ar_fina  g_hah_threedotsabove_ar_fina
		g_tcheheh_ar_fina  g_tcheh_dotabove_ar_fina  g_tcheh_vabove_ar_fina
		g_hah_tah_twodotshorizontalbelow_ar_fina  g_hah_tahbelow_ar_fina  g_hah_tahabove_ar_fina
		g_hah_twodotshorizontalabove_ar_fina  g_hah_threedotsupbelow_ar_fina  g_hah_fourbelow_ar_fina
		g_hah_twodotsverticalabove_ar_fina  g_jeem_twodotsabove_ar_fina
		g_jeem_threedotsabove_ar_fina  g_jeem_threedotsbelow_ar_fina
		g_ain_ar_fina  g_ain_threedots_ar_fina  g_ain_twodotshorizontalabove_ar_fina  g_ain_threedotsdownabove_ar_fina
		g_ain_twodotsverticalabove_ar_fina  g_ain_threedotsbelow_ar_fina  g_ghain_ar_fina
		g_ghain_threedots_ar_fina  g_ghain_dotbelow_ar_fina
		g_yehbarree_ar_fina  g_yehbarree_hamzaabove_ar_fina
		g_yehbarree_twoabove_ar_fina  g_yehbarree_threeabove_ar_fina );
		
g_abs_auto_kashida {dbgAw = aw; dbgBbW = bb.width};
		
endtable; // glyph

table(subs)

pass(6) // insert kashidas to handle collisions; however, the kashida we're inserting is
	// 250m, wider than we really need, so below we kern out some of the extra space

	cKafLikeIniMed  _  >  @1 g_abs_auto_kashida:R / _ MARKS _ cRnoonLikeMed=R;
	cTooth2wBelowIni  _  >  @1 g_abs_auto_kashida:Y / _ MARKS _ (cTooth2wBelowMed cYehLikeFin)=Y;
	(g_keheh_ar_init  g_gaf_ar_init  g_tcheh_ar_init  g_tcheh_ar_medi  g_noon_ar_medi) _
		     >  @1  g_abs_auto_kashida:R
		     / _  MARKS  _  g_rreh_ar_fina=R ;
	
endpass; // 6

endtable; // sub

////if (debug == 0)
pass(3)	// Collisions and adjustments

	// Kashidas
	
	// kaf + rnoon
	cKafLikeIniMed  MARKS  g_abs_auto_kashida {kern.x = -30m}  cRnoonLikeMed {kern.x = -30m};
		
	// yeh-barree + yeh
	cTooth2wBelowIni MARKS g_abs_auto_kashida {kern.x = -30m} (cTooth2wBelowMed cYehLikeFin) {kern.x = -30m};
	
	// keheh-rreh
	(g_keheh_ar_init  g_gaf_ar_init  g_tcheh_ar_init  g_tcheh_ar_medi  g_noon_ar_medi) MARKS
		g_abs_auto_kashida {kern.x = -40m}  g_rreh_ar_fina {kern.x = -40m };


	// Simple adjustments
		
	// alef-rreh
	(g_alef_ar  g_alef_ar_fina) MARKS g_rreh_ar {kern.x = 70m} ;

	// alef-nameMarker
	(g_alef_ar g_alef_ar_fina) MARKS (g_heh_ar  g_hehgoal_ar  g_hehgoal_ar_init)
		g_takhallusabove_ar {shift.y = 220m}; // or: {shift.x = 250m};
		
	// noonGhunna-vowelInvSmallV
	// cNoonGhunna (absNoonGhunnaMark absVowelInvSmallV) {shift.y = -75m}
	//	/ (absKafIni absKafMed absKehehIni absKehehMed) _ _;
	// cNoonGhunna (absNoonGhunnaMark absVowelInvSmallV) {shift.y = -150m};

	// beh-kasra-tcheh -- kasra collides with tail of tcheh/ain/yeh-barree. 
	// if (kasraTcheh == raise)
	//	cTooth1hBelow absKasra {shift.x = -60m; shift.y = 125m} cTchehLikeFin / _ _ MARKS _;
	//	cTooth1hBelow absKasratan {shift.x = -100m; shift.y = 30m} cTchehLikeFin / _ _ MARKS _;
	// endif;
	// if (kasraTcheh == lower)
	// 	cTooth1hBelow absKasra {shift.x = -40m; shift.y = -200m} cTchehLikeFin / _ _ MARKS _;
	// 	cTooth1hBelow absKasratan {shift.x = -60m; shift.y = -130m} cTchehLikeFin / _ _ MARKS _;
	// endif;
//	cTooth2hBelow absKasra {shift.y = -50m} cTchehLikeFin / _ _ MARKS _;
//	cTooth2hBelow absKasratan {shift.x = -50m} cTchehLikeFin / _ _ MARKS _;
//	cTooth0Below absKasratan {shift.x = -80m} cTchehLikeFin / _ _ MARKS _;
	
	// alef-maddah-gaf
	// absAlef absMaddahAbove {shift.x = -130m} absGaf {kern.x = 30m};
	// absAlef absMaddahAbove {shift.x = -120m} absGafIni {kern.x = 70m};

	// beh-rehBar
	// cTooth1hBelow MARKS absRehBarFin {kern.x = 50m};
	//cTooth2hBelow MARKS absRehBarFin {kern.x = 70m};

	// beh-fatha-jehRetro
	// (cTooth1hBelow cTooth2hBelow cTooth0Below) MARKS cMark2Above MARKS absRehSmallTahTwoDotsFin {kern.x = 65m};

	// kehehDots-keheh
	// (absKehehThreeDotsAboveIni absKehehThreeDotsAboveMed) MARKS cKehehLikeFin {kern.x = 70m};
	
	// was a test: 
	// absBeh absKasra {shift.x = 200m};
	// absBeeh absKasra {shift.x = -200m};
	
endpass;

////endif;

endtable; // pos

endenvironment;
